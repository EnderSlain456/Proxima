"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureEmpty = exports.filesExist = exports.symlinkPaths = exports.createSymlink = exports.appendToFileSync = exports.mkdirpSync = exports.mkdirp = exports.ensureDir = exports.walkDirectoryTree = exports.walkDirectory = exports.windowsPathToUnix = void 0;
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const path_1 = require("path");
const log_1 = require("../log");
/**
 * On windows, converts a windows style path to a unix path. On unix, passes the
 * output through to the other side
 *
 * @param path The path that you want to be converted to a unix path
 * @returns A unix path
 */
const windowsPathToUnix = (path) => process.platform == 'win32' ? path.replace(/\\/g, '/') : path;
exports.windowsPathToUnix = windowsPathToUnix;
async function walkDirectory(dirName) {
    const output = [];
    if (!(0, path_1.isAbsolute)(dirName)) {
        log_1.log.askForReport();
        log_1.log.error('Please provide an absolute input to walkDirectory');
    }
    try {
        const directoryContents = await (0, promises_1.readdir)(dirName);
        for (const file of directoryContents) {
            const fullPath = (0, path_1.join)(dirName, file);
            const fStat = await (0, promises_1.stat)(fullPath);
            if (fStat.isDirectory()) {
                for (const newFile of await walkDirectory(fullPath)) {
                    output.push(newFile);
                }
            }
            else {
                output.push(fullPath);
            }
        }
    }
    catch (e) {
        log_1.log.askForReport();
        log_1.log.error(e);
    }
    return output;
}
exports.walkDirectory = walkDirectory;
async function walkDirectoryTree(dirName) {
    const output = {};
    if (!(0, path_1.isAbsolute)(dirName)) {
        log_1.log.askForReport();
        log_1.log.error('Please provide an absolute input to walkDirectory');
    }
    try {
        const directoryContents = await (0, promises_1.readdir)(dirName);
        const currentOut = [];
        for (const file of directoryContents) {
            const fullPath = (0, path_1.join)(dirName, file);
            const fStat = await (0, promises_1.stat)(fullPath);
            if (fStat.isDirectory()) {
                output[file] = await walkDirectoryTree(fullPath);
            }
            else {
                currentOut.push(fullPath);
            }
        }
        output['.'] = currentOut;
    }
    catch (e) {
        log_1.log.askForReport();
        log_1.log.error(e);
    }
    return output;
}
exports.walkDirectoryTree = walkDirectoryTree;
async function ensureDir(dirName) {
    if (!(0, fs_1.existsSync)(dirName)) {
        await mkdirp(dirName);
    }
}
exports.ensureDir = ensureDir;
function mkdirp(dirName) {
    return (0, promises_1.mkdir)(dirName, { recursive: true });
}
exports.mkdirp = mkdirp;
function mkdirpSync(dirName) {
    return (0, fs_1.mkdirSync)(dirName, { recursive: true });
}
exports.mkdirpSync = mkdirpSync;
function appendToFileSync(fileName, content) {
    const file = (0, fs_1.openSync)(fileName, 'a');
    (0, fs_1.writeSync)(file, content);
    (0, fs_1.closeSync)(file);
}
exports.appendToFileSync = appendToFileSync;
async function createSymlink(srcPath, destPath, type) {
    if ((0, fs_1.existsSync)(destPath))
        return;
    const { toDest: src } = symlinkPaths(srcPath, destPath);
    const dir = (0, path_1.dirname)(destPath);
    const exists = (0, fs_1.existsSync)(dir);
    if (exists)
        return await (0, promises_1.symlink)(src, destPath, type);
    await mkdirp(dir);
    return await (0, promises_1.symlink)(src, destPath, type);
}
exports.createSymlink = createSymlink;
/**
 * Adapted from fs-extra
 * @param srcPath
 * @param destPath
 * @returns
 */
function symlinkPaths(srcPath, destPath) {
    if ((0, path_1.isAbsolute)(srcPath)) {
        if (!(0, fs_1.existsSync)(srcPath))
            throw new Error('absolute srcpath does not exist');
        return {
            toCwd: srcPath,
            toDest: srcPath,
        };
    }
    else {
        const dstdir = (0, path_1.dirname)(destPath);
        const relativeToDst = (0, path_1.join)(dstdir, srcPath);
        if ((0, fs_1.existsSync)(relativeToDst))
            return {
                toCwd: relativeToDst,
                toDest: srcPath,
            };
        else {
            if (!(0, fs_1.existsSync)(srcPath))
                throw new Error('relative srcpath does not exist');
            return {
                toCwd: srcPath,
                toDest: (0, path_1.relative)(dstdir, srcPath),
            };
        }
    }
}
exports.symlinkPaths = symlinkPaths;
function filesExist(files) {
    return files.every((file) => (0, fs_1.existsSync)(file));
}
exports.filesExist = filesExist;
function ensureEmpty(path) {
    if ((0, fs_1.existsSync)(path)) {
        (0, fs_1.rmdirSync)(path, { recursive: true });
    }
    (0, fs_1.mkdirSync)(path, { recursive: true });
}
exports.ensureEmpty = ensureEmpty;
