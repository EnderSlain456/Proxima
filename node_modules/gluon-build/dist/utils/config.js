"use strict";
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
/**
 * Responsible for loading, parsing and checking the config file for melon
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.config = exports.getConfig = exports.rawConfig = exports.setMockRawConfig = exports.hasConfig = exports.defaultConfig = exports.defaultLicenseConfig = exports.defaultBrandsConfig = exports.validProducts = exports.SupportedProducts = exports.configPath = exports.projectDir = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const log_1 = require("../log");
exports.projectDir = process.cwd();
exports.configPath = (0, path_1.join)(exports.projectDir, 'gluon.json');
let hasWarnedAboutConfig = false;
var SupportedProducts;
(function (SupportedProducts) {
    SupportedProducts["Firefox"] = "firefox";
    SupportedProducts["FirefoxESR"] = "firefox-esr";
    SupportedProducts["FirefoxESRNext"] = "firefox-esr-next";
    SupportedProducts["FirefoxDev"] = "firefox-dev";
    SupportedProducts["FirefoxBeta"] = "firefox-beta";
    SupportedProducts["FirefoxNightly"] = "firefox-nightly";
})(SupportedProducts = exports.SupportedProducts || (exports.SupportedProducts = {}));
exports.validProducts = [
    SupportedProducts.Firefox,
    SupportedProducts.FirefoxESR,
    SupportedProducts.FirefoxESRNext,
    SupportedProducts.FirefoxDev,
    SupportedProducts.FirefoxBeta,
    SupportedProducts.FirefoxNightly,
];
exports.defaultBrandsConfig = {
    backgroundColor: '#2B2A33',
    brandShorterName: 'Nightly',
    brandShortName: 'Nightly',
    brandFullName: 'Nightly',
};
exports.defaultLicenseConfig = {
    ignoredFiles: ['.*\\.json'],
    licenseType: 'MPL-2.0',
};
exports.defaultConfig = {
    name: 'Unknown melon build',
    vendor: 'Unknown',
    appId: 'unknown.appid',
    binaryName: 'firefox',
    version: {
        product: SupportedProducts.Firefox,
        displayVersion: '1.0.0',
    },
    buildOptions: {
        generateBranding: true,
        windowsUseSymbolicLinks: false,
    },
    addons: {},
    brands: {},
    license: exports.defaultLicenseConfig,
};
function hasConfig() {
    return (0, fs_1.existsSync)(exports.configPath);
}
exports.hasConfig = hasConfig;
let mockConfig = '';
function setMockRawConfig(config) {
    mockConfig = config;
}
exports.setMockRawConfig = setMockRawConfig;
function rawConfig() {
    if (mockConfig != '') {
        return mockConfig;
    }
    const configExists = hasConfig();
    let contents = '{}';
    if (configExists) {
        contents = (0, fs_1.readFileSync)(exports.configPath).toString();
    }
    else {
        if (!hasWarnedAboutConfig) {
            log_1.log.warning(`Config file not found at ${exports.configPath}. It is recommended to create one by running |melon setup-project|`);
            hasWarnedAboutConfig = true;
        }
    }
    return contents;
}
exports.rawConfig = rawConfig;
function getConfig() {
    const fileContents = rawConfig();
    let fileParsed;
    try {
        // Try to parse the contents of the file. May not be valid JSON
        fileParsed = JSON.parse(fileContents);
    }
    catch (e) {
        // Report the error to the user
        log_1.log.error(`Error parsing melon config file located at ${exports.configPath}`);
        log_1.log.error(e);
        process.exit(1);
    }
    // Provide some useful warnings to the user to help improve their config files
    if (!fileParsed.binaryName) {
        log_1.log.warning('It is recommended that you provide a `binaryName` field in your config file, otherwise packaging may get messed up');
    }
    // Merge the default config with the file parsed config
    fileParsed = { ...exports.defaultConfig, ...fileParsed };
    fileParsed.license = { ...exports.defaultLicenseConfig, ...fileParsed.license };
    // ===========================================================================
    // Config Validation
    if (!exports.validProducts.includes(fileParsed.version.product)) {
        log_1.log.error(`${fileParsed.version.product} is not a valid product`);
        process.exit(1);
    }
    return fileParsed;
}
exports.getConfig = getConfig;
exports.config = getConfig();
