"use strict";
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
// This file was originally under the MIT license, but is now under the MPL 2.0
// license. The following license notice applies to only this file
//
// The MIT License (MIT)
//
// Copyright (c) 2014 Matthew Conlen
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// Adapted from the `command-exists` node module
// https://github.com/mathisonian/command-exists
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.commandExistsSync = void 0;
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const onWindows = process.platform == 'win32';
const fileNotExistsSync = (commandName) => {
    try {
        (0, fs_1.accessSync)(commandName, fs_1.constants.F_OK);
        return false;
    }
    catch (e) {
        return true;
    }
};
const localExecutableSync = (commandName) => {
    try {
        (0, fs_1.accessSync)(commandName, fs_1.constants.F_OK | fs_1.constants.X_OK);
        return true;
    }
    catch (e) {
        return false;
    }
};
const commandExistsUnixSync = function (commandName, cleanedCommandName) {
    if (fileNotExistsSync(commandName)) {
        try {
            const stdout = (0, child_process_1.execSync)('command -v ' +
                cleanedCommandName +
                ' 2>/dev/null' +
                ' && { echo >&1 ' +
                cleanedCommandName +
                '; exit 0; }');
            return !!stdout;
        }
        catch (error) {
            return false;
        }
    }
    return localExecutableSync(commandName);
};
const commandExistsWindowsSync = function (commandName, cleanedCommandName) {
    // Regex from Julio from: https://stackoverflow.com/questions/51494579/regex-windows-path-validator
    if (!/^(?!(?:.*\s|.*\.|\W+)$)(?:[a-zA-Z]:)?(?:(?:[^<>:"|?*\n])+(?:\/\/|\/|\\\\|\\)?)+$/m.test(commandName)) {
        return false;
    }
    try {
        const stdout = (0, child_process_1.execSync)('where ' + cleanedCommandName, { stdio: [] });
        return !!stdout;
    }
    catch (error) {
        return false;
    }
};
function cleanInput(toBeCleaned) {
    // Windows has a different cleaning process to Unix, so we should go through
    // that process first
    if (onWindows) {
        const isPathName = /[\\]/.test(toBeCleaned);
        if (isPathName) {
            const dirname = '"' + path_1.default.dirname(toBeCleaned) + '"';
            const basename = '"' + path_1.default.basename(toBeCleaned) + '"';
            return `${dirname}:${basename}`;
        }
        return `"${toBeCleaned}"`;
    }
    // Otherwise go through the unix cleaning process
    if (/[^A-Za-z0-9_\\/:=-]/.test(toBeCleaned)) {
        toBeCleaned = "'" + toBeCleaned.replace(/'/g, "'\\''") + "'";
        toBeCleaned = toBeCleaned
            .replace(/^(?:'')+/g, '') // unduplicate single-quote at the beginning
            .replace(/\\'''/g, "\\'"); // remove non-escaped single-quote if there are enclosed between 2 escaped
    }
    return toBeCleaned;
}
function commandExistsSync(commandName) {
    const cleanedCommandName = cleanInput(commandName);
    if (onWindows) {
        return commandExistsWindowsSync(commandName, cleanedCommandName);
    }
    else {
        return commandExistsUnixSync(commandName, cleanedCommandName);
    }
}
exports.commandExistsSync = commandExistsSync;
