"use strict";
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dispatch = exports.configDispatch = exports.removeTimestamp = void 0;
const execa_1 = __importDefault(require("execa"));
const constants_1 = require("../constants");
const log_1 = require("../log");
const removeTimestamp = (input) => input.replace(/\s\d{1,5}:\d\d\.\d\d /g, '');
exports.removeTimestamp = removeTimestamp;
const configDispatch = (cmd, config) => {
    // Provide a default logger if none was specified by the user
    const logger = (config === null || config === void 0 ? void 0 : config.logger) || ((data) => log_1.log.info(data));
    // Decide what shell we should be using. False will use the system default
    let shell = false;
    if (config === null || config === void 0 ? void 0 : config.shell) {
        switch (config.shell) {
            // Don't change anything if we are using the default shell
            case 'default':
                break;
            case 'unix':
                // Bash path provides a unix shell on windows
                shell = constants_1.BASH_PATH || false;
                break;
            default:
                log_1.log.error(`dispatch() does not understand the shell '${shell}'`);
                break;
        }
    }
    const handle = (data, killOnError) => {
        const d = data.toString();
        d.split('\n').forEach((line) => {
            if (line.length !== 0)
                logger((0, exports.removeTimestamp)(line));
        });
        if (killOnError) {
            log_1.log.error('Command failed. See error above.');
        }
    };
    return new Promise((resolve) => {
        var _a, _b, _c, _d;
        const proc = (0, execa_1.default)(cmd, config === null || config === void 0 ? void 0 : config.args, {
            cwd: (config === null || config === void 0 ? void 0 : config.cwd) || process.cwd(),
            shell: shell,
            env: process.env,
        });
        (_a = proc.stdout) === null || _a === void 0 ? void 0 : _a.on('data', (d) => handle(d));
        (_b = proc.stderr) === null || _b === void 0 ? void 0 : _b.on('data', (d) => handle(d));
        (_c = proc.stdout) === null || _c === void 0 ? void 0 : _c.on('error', (d) => handle(d, (config === null || config === void 0 ? void 0 : config.killOnError) || false));
        (_d = proc.stderr) === null || _d === void 0 ? void 0 : _d.on('error', (d) => handle(d, (config === null || config === void 0 ? void 0 : config.killOnError) || false));
        proc.on('exit', () => {
            resolve(true);
        });
    });
};
exports.configDispatch = configDispatch;
/**
 * @deprecated Use configDispatch instead
 */
const dispatch = (cmd, args, cwd, killOnError, logger = (data) => log_1.log.info(data)) => {
    return (0, exports.configDispatch)(cmd, {
        args: args,
        cwd: cwd,
        killOnError: killOnError,
        logger: logger,
    });
};
exports.dispatch = dispatch;
