"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.licenseCheck = exports.listrCheckFile = exports.isValidLicense = void 0;
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
const promises_1 = require("fs/promises");
const listr_1 = __importDefault(require("listr"));
const path_1 = require("path");
const constants_1 = require("../constants");
const fs_1 = require("../utils/fs");
const ignoredFiles = new RegExp('.*\\.(json|patch|md|jpeg|png|gif|tiff|ico)');
const licenseIgnore = new RegExp('(//|#) Ignore license in this file', 'g');
const fixableFiles = [
    { regex: new RegExp('.*\\.(j|t)s'), comment: '// ', commentClose: '\n' },
    {
        regex: new RegExp('.*(\\.inc)?\\.css'),
        commentOpen: '/*\n',
        comment: ' * ',
        commentClose: '\n */',
    },
    {
        regex: new RegExp('.*\\.(html|svg|xml)'),
        commentOpen: '<!--\n',
        comment: '   - ',
        commentClose: '\n   -->',
    },
    {
        regex: new RegExp('.*\\.py|moz\\.build'),
        comment: '# ',
        commentClose: '\n',
    },
];
async function isValidLicense(path) {
    const file = (await (0, promises_1.readFile)(path)).toString();
    const contents = file.split('\n');
    // We need to grab the top 5 lines just in case there are newlines in the
    // comment blocks
    const lines = [
        contents[0],
        contents[1],
        contents[2],
        contents[3],
        contents[4],
    ].join('\n');
    const hasLicense = (lines.includes('the Mozilla Public') &&
        lines.includes('If a copy of the MPL was') &&
        lines.includes('http://mozilla.org/MPL/2.0/')) ||
        licenseIgnore.test(contents.join('\n'));
    return hasLicense;
}
exports.isValidLicense = isValidLicense;
function listrCheckFile(path, noFix) {
    return {
        skip: () => ignoredFiles.test(path),
        title: path.replace(constants_1.SRC_DIR, ''),
        task: async () => {
            const contents = (await (0, promises_1.readFile)(path)).toString().split('\n');
            const hasLicense = await isValidLicense(path);
            if (!hasLicense) {
                const fixable = fixableFiles.find(({ regex }) => regex.test(path));
                if (!fixable || noFix) {
                    throw new Error(`${path} does not have a license. Please add the source code header`);
                }
                else {
                    const mpl = (await (0, promises_1.readFile)((0, path_1.join)(__dirname, 'license-check.txt'))).toString();
                    const { comment, commentOpen, commentClose } = fixable;
                    let header = mpl
                        .split('\n')
                        .map((ln) => (comment || '') + ln)
                        .join('\n');
                    if (commentOpen) {
                        header = commentOpen + header + commentClose;
                    }
                    await (0, promises_1.writeFile)(path, header + '\n' + contents.join('\n'));
                }
            }
        },
    };
}
exports.listrCheckFile = listrCheckFile;
const licenseCheck = async (options) => {
    const files = await (0, fs_1.walkDirectory)(constants_1.SRC_DIR);
    await new listr_1.default(files.map((file) => listrCheckFile(file, options.noFix)), {
        concurrent: true,
        exitOnError: false,
    }).run();
};
exports.licenseCheck = licenseCheck;
