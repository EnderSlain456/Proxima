"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.melonPackage = void 0;
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const path_1 = require("path");
const __1 = require("..");
const constants_1 = require("../constants");
const log_1 = require("../log");
const utils_1 = require("../utils");
const machPath = (0, path_1.resolve)(constants_1.ENGINE_DIR, 'mach');
const melonPackage = async () => {
    // The engine directory must have been downloaded for this to be valid
    // TODO: Make this a reusable function that can be used by everything
    if (!(0, fs_1.existsSync)(constants_1.ENGINE_DIR)) {
        log_1.log.error(`Unable to locate any source directories.\nRun |${__1.bin_name} download| to generate the source directory.`);
    }
    if (!(0, fs_1.existsSync)(machPath)) {
        log_1.log.error(`Cannot locate the 'mach' binary within ${constants_1.ENGINE_DIR}`);
    }
    const args = ['package'];
    log_1.log.info(`Packaging \`${__1.config.binaryName}\` with args ${JSON.stringify(args.slice(1, 0))}...`);
    await (0, utils_1.dispatch)(machPath, args, constants_1.ENGINE_DIR, true);
    log_1.log.info('Copying results up');
    log_1.log.debug("Creating the dist directory if it doesn't exist");
    if (!(0, fs_1.existsSync)(constants_1.DIST_DIR))
        await (0, promises_1.mkdir)(constants_1.DIST_DIR, { recursive: true });
    log_1.log.debug('Indexing files to copy');
    const files = (await (0, promises_1.readdir)((0, path_1.join)(constants_1.OBJ_DIR, 'dist'), { withFileTypes: true }))
        .filter((entry) => entry.isFile())
        .map((entry) => entry.name);
    for (const file of files) {
        const destFile = (0, path_1.join)(constants_1.DIST_DIR, file);
        log_1.log.debug(`Copying ${file}`);
        if ((0, fs_1.existsSync)(destFile))
            await (0, promises_1.unlink)(destFile);
        await (0, promises_1.copyFile)((0, path_1.join)(constants_1.OBJ_DIR, 'dist', file), destFile);
    }
    // Windows has some special dist files that are available within the dist
    // directory.
    if (process.platform == 'win32') {
        const installerDistDirectory = (0, path_1.join)(constants_1.OBJ_DIR, 'dist', 'install', 'sea');
        if (!(0, fs_1.existsSync)(installerDistDirectory)) {
            log_1.log.error(`Could not find windows installer files located at '${installerDistDirectory}'`);
        }
        const windowsInstallerFiles = (await (0, promises_1.readdir)(installerDistDirectory, { withFileTypes: true }))
            .filter((entry) => entry.isFile())
            .map((entry) => entry.name);
        for (const file of windowsInstallerFiles) {
            let newFileName = file;
            // There are some special cases that I want to reformat the name for
            if (file.includes('.installer.exe')) {
                newFileName = `${__1.config.binaryName}.installer.exe`;
            }
            if (file.includes('.installer-stub.exe')) {
                newFileName = `${__1.config.binaryName}.installer.pretty.exe`;
                log_1.log.warning(`The installer ${newFileName} requires that your binaries are available from the internet and everything is correctly configured. I recommend you ship '${__1.config.binaryName}.installer.exe' if you have not set this up correctly yet`);
            }
            // Actually copy
            const destFile = (0, path_1.join)(constants_1.DIST_DIR, newFileName);
            log_1.log.debug(`Copying ${file}`);
            if ((0, fs_1.existsSync)(destFile))
                await (0, promises_1.unlink)(destFile);
            await (0, promises_1.copyFile)((0, path_1.join)(installerDistDirectory, file), destFile);
        }
    }
    log_1.log.info();
    log_1.log.info(`Output written to ${constants_1.DIST_DIR}`);
    log_1.log.success('Packaging complected!');
};
exports.melonPackage = melonPackage;
