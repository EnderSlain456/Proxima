"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.download = void 0;
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
const fs_1 = require("fs");
const path_1 = require("path");
const execa_1 = __importDefault(require("execa"));
const listr_1 = __importDefault(require("listr"));
const __1 = require("..");
const constants_1 = require("../constants");
const utils_1 = require("../utils");
const download_1 = require("../utils/download");
const store_1 = require("../utils/store");
const discard_1 = require("./discard");
const init_1 = require("./init");
const log_1 = require("../log");
const gFFVersion = (0, utils_1.getConfig)().version.version;
const download = async () => {
    const version = gFFVersion;
    // If gFFVersion isn't specified, provide legible error
    if (!version) {
        log_1.log.error('You have not specified a version of firefox in your config file. This is required to build a firefox fork');
        process.exit(1);
    }
    const addons = Object.keys(__1.config.addons).map((addon) => ({
        name: addon,
        ...__1.config.addons[addon],
    }));
    // Listr and typescript do not mix. Just specify any and move on with the
    // rest of our life
    //
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    await new listr_1.default([
        {
            title: 'Downloading firefox source',
            skip: () => {
                if ((0, fs_1.existsSync)(constants_1.ENGINE_DIR) &&
                    (0, fs_1.existsSync)((0, path_1.resolve)(constants_1.ENGINE_DIR, 'toolkit', 'moz.build'))) {
                    return 'Firefox has already been downloaded, unpacked and inited';
                }
            },
            task: async (ctx, task) => {
                ctx.firefoxSourceTar = await downloadFirefoxSource(version, task);
            },
        },
        {
            title: 'Unpack firefox source',
            enabled: (ctx) => ctx.firefoxSourceTar,
            task: async (ctx, task) => {
                await unpackFirefoxSource(ctx.firefoxSourceTar, task);
            },
        },
        {
            title: 'Init firefox',
            enabled: (ctx) => ctx.firefoxSourceTar && !process.env.CI_SKIP_INIT,
            task: async (_ctx, task) => await (0, init_1.init)(constants_1.ENGINE_DIR, task),
        },
        ...addons
            .map((addon) => includeAddon(addon.name, addon.url, addon.id))
            .reduce((acc, cur) => [...acc, ...cur], []),
        {
            title: 'Add addons to mozbuild',
            task: async () => {
                // Discard the file to make sure it has no changes
                await (0, discard_1.discard)('browser/extensions/moz.build');
                const path = (0, path_1.join)(constants_1.ENGINE_DIR, 'browser', 'extensions', 'moz.build');
                // Append all the files to the bottom
                (0, fs_1.writeFileSync)(path, `${(0, fs_1.readFileSync)(path).toString()}\nDIRS += [${addons
                    .map((addon) => addon.name)
                    .sort()
                    .map((addon) => `"${addon}"`)
                    .join(',')}]`);
            },
        },
        {
            title: 'Cleanup',
            task: (ctx) => {
                let cwd = process.cwd().split(path_1.sep).join(path_1.posix.sep);
                if (process.platform == 'win32') {
                    cwd = './';
                }
                if (ctx.firefoxSourceTar) {
                    if (typeof ctx.firefoxSourceTar !== 'string') {
                        log_1.log.askForReport();
                        log_1.log.error(`The type ctx.firefoxSourceTar was ${typeof ctx.firefoxSourceTar} when it should have been a string`);
                        return;
                    }
                    (0, fs_1.unlinkSync)((0, path_1.resolve)(constants_1.MELON_TMP_DIR, ctx.firefoxSourceTar));
                }
            },
        },
    ], {
        renderer: log_1.log.isDebug ? 'verbose' : 'default',
    }).run();
    log_1.log.success(`You should be ready to make changes to ${__1.config.name}.\n\n\t   You should import the patches next, run |${__1.bin_name} import|.\n\t   To begin building ${__1.config.name}, run |${__1.bin_name} build|.`);
    console.log();
};
exports.download = download;
const includeAddon = (name, downloadURL, id) => {
    const tempFile = (0, path_1.join)(constants_1.MELON_TMP_DIR, name + '.xpi');
    const outPath = (0, path_1.join)(constants_1.ENGINE_DIR, 'browser', 'extensions', name);
    return [
        {
            title: `Download addon from ${downloadURL}`,
            skip: () => {
                if ((0, fs_1.existsSync)(outPath)) {
                    // Now we need to do some tests. First, if there is no cache file,
                    // we must discard the existing folder and download the file again.
                    // If there is a cache file and the cache file points to the same path
                    // we can return and skip the download.
                    const extensionCache = (0, store_1.readItem)(name);
                    if (extensionCache.isNone()) {
                        // We haven't stored it in the cache, therefore we need to redonwload
                        // it
                    }
                    else {
                        const cache = extensionCache.unwrap();
                        if (cache.url == downloadURL) {
                            return `${downloadURL} has already been loaded to ${name}`;
                        }
                    }
                }
            },
            task: async (ctx, task) => {
                if ((0, fs_1.existsSync)(tempFile)) {
                    (0, fs_1.unlinkSync)(tempFile);
                }
                await (0, download_1.downloadFileToLocation)(downloadURL, tempFile, (msg) => (task.output = msg));
                ctx[name] = tempFile;
                // I do not know why, but this delay causes unzip to work reliably
                await (0, utils_1.delay)(200);
            },
        },
        {
            title: `Unpack to ${name}`,
            enabled: (ctx) => typeof ctx[name] !== 'undefined',
            task: async (ctx, task) => {
                task.output = `Unpacking extension...`;
                // I do not know why, but this delay causes unzip to work reliably
                await (0, utils_1.delay)(200);
                if ((0, fs_1.existsSync)(outPath)) {
                    (0, fs_1.rmdirSync)(outPath, { recursive: true });
                }
                (0, fs_1.mkdirSync)(outPath, {
                    recursive: true,
                });
                await (0, utils_1.configDispatch)('unzip', {
                    args: [
                        (0, utils_1.windowsPathToUnix)(ctx[name]),
                        '-d',
                        (0, utils_1.windowsPathToUnix)(outPath),
                    ],
                    killOnError: true,
                    logger: (data) => (task.output = data),
                    shell: 'unix',
                });
            },
        },
        {
            title: 'Generate mozbuild',
            enabled: (ctx) => typeof ctx[name] !== 'undefined',
            task: async () => {
                const files = await (0, utils_1.walkDirectoryTree)(outPath);
                // Because the tree has the potential of being infinitely recursive, we
                // cannot possibly know the the type of the tree
                //
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                function runTree(tree, parent) {
                    if (Array.isArray(tree)) {
                        return tree
                            .sort()
                            .map((file) => `FINAL_TARGET_FILES.features["${id}"]${parent} += ["${file
                            .replace(outPath + '/', '')
                            .replace(outPath, '')}"]`)
                            .join('\n');
                    }
                    const current = tree['.']
                        .sort()
                        // Don't use windows path, which brick mozbuild
                        .map((f) => (0, utils_1.windowsPathToUnix)(f))
                        .map((f) => `FINAL_TARGET_FILES.features["${id}"]${parent} += ["${f
                        .replace(outPath + '/', '')
                        .replace(outPath, '')}"]`)
                        .join('\n');
                    const children = Object.keys(tree)
                        .filter((folder) => folder !== '.')
                        .filter((folder) => typeof tree[folder] !== 'undefined')
                        .map((folder) => runTree(tree[folder], `${parent}["${folder}"]`))
                        .join('\n');
                    return `${current}\n${children}`;
                }
                (0, fs_1.writeFileSync)((0, path_1.join)(outPath, 'moz.build'), `
DEFINES["MOZ_APP_VERSION"] = CONFIG["MOZ_APP_VERSION"]
DEFINES["MOZ_APP_MAXVERSION"] = CONFIG["MOZ_APP_MAXVERSION"]

${runTree(files, '')}`);
            },
        },
        {
            // This step allows patches to be applied to extensions that are downloaded
            // providing more flexibility to the browser developers
            title: 'Initializing',
            enabled: (ctx) => typeof ctx[name] !== 'undefined',
            task: async (ctx, task) => {
                await (0, utils_1.configDispatch)('git', {
                    args: ['add', '-f', '.'],
                    cwd: outPath,
                    logger: (data) => (task.output = data),
                });
                await (0, utils_1.configDispatch)('git', {
                    args: ['commit', '-m', name],
                    cwd: constants_1.ENGINE_DIR,
                    logger: (data) => (task.output = data),
                });
            },
        },
    ];
};
async function unpackFirefoxSource(name, task) {
    let cwd = process.cwd().split(path_1.sep).join(path_1.posix.sep);
    if (process.platform == 'win32') {
        cwd = './';
    }
    task.output = `Unpacking Firefox...`;
    if ((0, fs_1.existsSync)(constants_1.ENGINE_DIR))
        (0, fs_1.rmdirSync)(constants_1.ENGINE_DIR);
    (0, fs_1.mkdirSync)(constants_1.ENGINE_DIR);
    let tarExec = 'tar';
    // On MacOS, we need to use gnu tar, otherwise tar doesn't behave how we
    // would expect it to behave, so this section is responsible for handling
    // that
    //
    // If BSD tar adds --transform support in the future, we can use that
    // instead
    if (process.platform == 'darwin') {
        // GNU Tar doesn't come preinstalled on any MacOS machines, so we need to
        // check for it and ask for the user to install it if necessary
        if (!(0, utils_1.commandExistsSync)('gtar')) {
            throw new Error(`GNU Tar is required to extract Firefox's source on MacOS. Please install it using the command |brew install gnu-tar| and try again`);
        }
        tarExec = 'gtar';
    }
    await (0, execa_1.default)(tarExec, [
        '--strip-components=1',
        process.platform == 'win32' ? '--force-local' : null,
        '-xf',
        (0, utils_1.windowsPathToUnix)((0, path_1.resolve)(constants_1.MELON_TMP_DIR, name)),
        '-C',
        (0, utils_1.windowsPathToUnix)(constants_1.ENGINE_DIR),
    ].filter((x) => x), {
        // HACK: Use bash shell on windows to get a sane version of tar that works
        shell: constants_1.BASH_PATH || false,
    });
}
// TODO: Make this function cache its output
async function downloadFirefoxSource(version, task) {
    const base = `https://archive.mozilla.org/pub/firefox/releases/${version}/source/`;
    const filename = `firefox-${version}.source.tar.xz`;
    const url = base + filename;
    const fsParent = constants_1.MELON_TMP_DIR;
    const fsSaveLocation = (0, path_1.resolve)(fsParent, filename);
    task.output = `Locating Firefox release ${version}...`;
    await (0, utils_1.ensureDir)(fsParent);
    if ((0, fs_1.existsSync)(fsSaveLocation)) {
        task.output = 'Using cached download';
        return filename;
    }
    if (version.includes('b'))
        task.output =
            'WARNING Version includes non-numeric characters. This is probably a beta.';
    // Do not re-download if there is already an existing workspace present
    if ((0, fs_1.existsSync)(constants_1.ENGINE_DIR)) {
        log_1.log.error(`Workspace already exists.\nRemove that workspace and run |${__1.bin_name} download ${version}| again.`);
    }
    task.output = `Downloading Firefox release ${version}...`;
    await (0, download_1.downloadFileToLocation)(url, (0, path_1.resolve)(constants_1.MELON_TMP_DIR, filename), (message) => (task.output = message));
    return filename;
}
