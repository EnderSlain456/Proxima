"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.apply = exports.get = exports.copyManual = void 0;
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
const glob_1 = require("glob");
const fs_1 = require("fs");
const fs_2 = require("fs");
const fs_extra_1 = require("fs-extra");
const promises_1 = require("fs/promises");
const path_1 = require("path");
const rimraf_1 = __importDefault(require("rimraf"));
const utils_1 = require("../../utils");
const __1 = require("../..");
const constants_1 = require("../../constants");
// =============================================================================
// Utilities
const getChunked = (location) => location.replace(/\\/g, '/').split('/');
const copyManual = async (name) => {
    // If the file exists and is not a symlink, we want to replace it with a
    // symlink to our file, so remove it
    if ((0, fs_1.existsSync)((0, path_1.resolve)(constants_1.ENGINE_DIR, ...getChunked(name))) &&
        !(0, fs_2.lstatSync)((0, path_1.resolve)(constants_1.ENGINE_DIR, ...getChunked(name))).isSymbolicLink()) {
        rimraf_1.default.sync((0, path_1.resolve)(constants_1.ENGINE_DIR, ...getChunked(name)));
    }
    if (process.platform == 'win32' &&
        !__1.config.buildOptions.windowsUseSymbolicLinks) {
        // Make the directory if it doesn't already exist.
        await (0, utils_1.mkdirp)((0, path_1.dirname)((0, path_1.resolve)(constants_1.ENGINE_DIR, ...getChunked(name))));
        // By default, windows users do not have access to the permissions to create
        // symbolic links. As a work around, we will just copy the files instead
        await (0, promises_1.copyFile)((0, path_1.resolve)(constants_1.SRC_DIR, ...getChunked(name)), (0, path_1.resolve)(constants_1.ENGINE_DIR, ...getChunked(name)));
    }
    else {
        // Create the symlink
        await (0, fs_extra_1.ensureSymlink)((0, path_1.resolve)(constants_1.SRC_DIR, ...getChunked(name)), (0, path_1.resolve)(constants_1.ENGINE_DIR, ...getChunked(name)));
    }
    const gitignore = (0, fs_2.readFileSync)((0, path_1.resolve)(constants_1.ENGINE_DIR, '.gitignore')).toString();
    if (!gitignore.includes(getChunked(name).join('/')))
        (0, utils_1.appendToFileSync)((0, path_1.resolve)(constants_1.ENGINE_DIR, '.gitignore'), `\n${getChunked(name).join('/')}`);
};
exports.copyManual = copyManual;
// =============================================================================
// Exports
function get() {
    const files = (0, glob_1.sync)('**/*', {
        nodir: true,
        cwd: constants_1.SRC_DIR,
    }).filter((f) => !(f.endsWith('.patch') || f.split('/').includes('node_modules')));
    const manualPatches = [];
    files.map((i) => {
        const group = i.split('/')[0];
        if (!manualPatches.find((m) => m.name == group)) {
            manualPatches.push({
                name: group,
                src: files.filter((f) => f.split('/')[0] == group),
            });
        }
    });
    return manualPatches;
}
exports.get = get;
async function apply(src) {
    for (const item of src) {
        await (0, exports.copyManual)(item);
    }
}
exports.apply = apply;
