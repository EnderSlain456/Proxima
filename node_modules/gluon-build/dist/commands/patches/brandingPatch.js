"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.apply = exports.get = exports.BRANDING_DIR = void 0;
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
const resvg_js_1 = require("@resvg/resvg-js");
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const modern_async_1 = require("modern-async");
const path_1 = require("path");
const sharp_1 = __importDefault(require("sharp"));
const png_to_ico_1 = __importDefault(require("png-to-ico"));
const async_icns_1 = __importDefault(require("async-icns"));
const __1 = require("../..");
const constants_1 = require("../../constants");
const log_1 = require("../../log");
const utils_1 = require("../../utils");
const setupProject_1 = require("../setupProject");
// =============================================================================
// Pure constants
exports.BRANDING_DIR = (0, path_1.join)(constants_1.CONFIGS_DIR, 'branding');
const BRANDING_STORE = (0, path_1.join)(constants_1.ENGINE_DIR, 'browser', 'branding');
const BRANDING_FF = (0, path_1.join)(BRANDING_STORE, 'unofficial');
const REQUIRED_FILES = ['logo.png'];
const CSS_REPLACE_REGEX = new RegExp('#130829|hsla\\(235, 43%, 10%, .5\\)', 'gm');
// =============================================================================
// Utility Functions
function checkForFaults(name, configPath) {
    if (!(0, fs_1.existsSync)(configPath)) {
        throw new Error(`Branding ${name} does not exist`);
    }
    const requiredFiles = REQUIRED_FILES.map((file) => (0, path_1.join)(configPath, file));
    const requiredFilesExist = (0, utils_1.filesExist)(requiredFiles);
    if (!requiredFilesExist) {
        throw new Error(`Missing some of the required files: ${requiredFiles
            .filter((file) => !(0, fs_1.existsSync)(file))
            .join(', ')}`);
    }
}
function constructConfig(name) {
    return {
        brandingGenericName: __1.config.name,
        brandingVendor: __1.config.vendor,
        ...utils_1.defaultBrandsConfig,
        ...(__1.config.brands[name] || {}),
    };
}
// =============================================================================
// Main code
async function setupImages(configPath, outputPath) {
    log_1.log.debug('Generating icons');
    // Firefox doesn't use 512 by 512, but we need it to generate ico files later
    await (0, modern_async_1.every)([16, 22, 24, 32, 48, 64, 128, 256, 512], async (size) => {
        await (0, sharp_1.default)((0, path_1.join)(configPath, 'logo.png'))
            .resize(size, size)
            .toFile((0, path_1.join)(outputPath, `default${size}.png`));
        await (0, promises_1.copyFile)((0, path_1.join)(outputPath, `default${size}.png`), (0, path_1.join)(configPath, `logo${size}.png`));
        return true;
    });
    log_1.log.debug('Generating Windows Icons');
    (0, fs_1.writeFileSync)((0, path_1.join)(outputPath, 'firefox.ico'), await (0, png_to_ico_1.default)([(0, path_1.join)(configPath, 'logo512.png')]));
    (0, fs_1.writeFileSync)((0, path_1.join)(outputPath, 'firefox64.ico'), await (0, png_to_ico_1.default)([(0, path_1.join)(configPath, 'logo64.png')]));
    // TODO: Custom MacOS icon support
    if (process.platform == 'darwin') {
        log_1.log.debug('Generating Mac Icons');
        const tmp = (0, path_1.join)(constants_1.MELON_TMP_DIR, 'macos_icon_info.iconset');
        if ((0, fs_1.existsSync)(tmp))
            await (0, promises_1.rmdir)(tmp, { recursive: true });
        async_icns_1.default.convert({
            input: (0, path_1.join)(configPath, 'logo.png'),
            output: (0, path_1.join)(outputPath, 'firefox.icns'),
            sizes: [16, 32, 64, 128, 256, 512],
            tmpDirectory: tmp,
        });
    }
    (0, fs_1.mkdirSync)((0, path_1.join)(outputPath, 'content'), { recursive: true });
    await (0, sharp_1.default)((0, path_1.join)(configPath, 'logo.png'))
        .resize(512, 512)
        .toFile((0, path_1.join)(outputPath, 'content', 'about-logo.png'));
    await (0, sharp_1.default)((0, path_1.join)(configPath, 'logo.png'))
        .resize(1024, 1024)
        .toFile((0, path_1.join)(outputPath, 'content', 'about-logo@2x.png'));
    // Register logo in cache
    await (0, utils_1.addHash)((0, path_1.join)(configPath, 'logo.png'));
    log_1.log.debug('Generating macos install');
    const macosInstall = await (0, resvg_js_1.renderAsync)(await (0, promises_1.readFile)((0, path_1.join)(configPath, 'MacOSInstaller.svg')));
    await (0, promises_1.writeFile)((0, path_1.join)(outputPath, 'content', 'background.png'), macosInstall);
    await (0, utils_1.addHash)((0, path_1.join)(configPath, 'MacOSInstaller.svg'));
}
async function setupLocale(outputPath, brandingConfig) {
    // eslint-disable-next-line @typescript-eslint/no-extra-semi
    ;
    (await (0, utils_1.walkDirectory)((0, path_1.join)(setupProject_1.templateDir, 'branding.optional')))
        .map((file) => (0, utils_1.windowsPathToUnix)(file).replace((0, utils_1.windowsPathToUnix)((0, path_1.join)(setupProject_1.templateDir, 'branding.optional') + '/'), ''))
        .map((file) => [
        (0, fs_1.readFileSync)((0, path_1.join)(setupProject_1.templateDir, 'branding.optional', file)).toString(),
        (0, path_1.join)(outputPath, file),
    ])
        .forEach(([contents, path]) => {
        (0, fs_1.mkdirSync)((0, path_1.dirname)(path), { recursive: true });
        (0, fs_1.writeFileSync)(path, (0, utils_1.stringTemplate)(contents, brandingConfig));
    });
}
async function copyMozFiles(outputPath, brandingConfig) {
    const files = (await (0, utils_1.walkDirectory)(BRANDING_FF)).filter((file) => !(0, fs_1.existsSync)((0, path_1.join)(outputPath, file.replace(BRANDING_FF, ''))));
    const css = files.filter((file) => (0, path_1.extname)(file).includes('css'));
    const everythingElse = files.filter((file) => !css.includes(file));
    css
        .map((filePath) => [
        (0, fs_1.readFileSync)(filePath).toString(),
        (0, path_1.join)(outputPath, filePath.replace(BRANDING_FF, '')),
    ])
        .map(([contents, path]) => [
        contents.replace(CSS_REPLACE_REGEX, 'var(--theme-bg)') +
            `:root { --theme-bg: ${brandingConfig.backgroundColor} }`,
        path,
    ])
        .forEach(([contents, path]) => {
        (0, fs_1.mkdirSync)((0, path_1.dirname)(path), { recursive: true });
        (0, fs_1.writeFileSync)(path, contents);
    });
    // Copy everything else from the default firefox branding directory
    everythingElse.forEach((file) => {
        (0, utils_1.mkdirpSync)((0, path_1.dirname)((0, path_1.join)(outputPath, file.replace(BRANDING_FF, ''))));
        (0, fs_1.copyFileSync)(file, (0, path_1.join)(outputPath, file.replace(BRANDING_FF, '')));
    });
}
function get() {
    return (0, fs_1.readdirSync)(exports.BRANDING_DIR).filter((file) => (0, fs_1.lstatSync)((0, path_1.join)(exports.BRANDING_DIR, file)).isDirectory());
}
exports.get = get;
async function apply(name) {
    const configPath = (0, path_1.join)(exports.BRANDING_DIR, name);
    const outputPath = (0, path_1.join)(BRANDING_STORE, name);
    checkForFaults(name, configPath);
    const brandingConfig = constructConfig(name);
    // Remove the output path if it exists and recreate it
    (0, utils_1.ensureEmpty)(outputPath);
    await setupImages(configPath, outputPath);
    await setupLocale(outputPath, brandingConfig);
    await copyMozFiles(outputPath, brandingConfig);
}
exports.apply = apply;
