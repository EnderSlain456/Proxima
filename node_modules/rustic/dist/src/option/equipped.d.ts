import { Option } from './types';
import { ResultEquipped } from '../result/equipped';
/**
 * Wrapper for Option<T> containing all methods (that make sense)
 * from Rust's Option<T>
 */
export declare class OptionEquipped<T> {
    private _opt;
    constructor(opt: Option<T>);
    get inner(): Option<T>;
    and<U>(optb: Option<U>): OptionEquipped<U>;
    andThen<U>(f: (a: T) => Option<U>): OptionEquipped<U>;
    contains(value: T): boolean;
    expect(msg: string): T;
    filter(f: (a: T) => boolean): OptionEquipped<T>;
    getOrInsert(value: T): T;
    getOrInsertWith(f: () => T): T;
    insert(value: T): T;
    isNone(): boolean;
    isSome(): boolean;
    map<U>(f: (a: T) => U): OptionEquipped<U>;
    mapOr<U>(d: U, f: (a: T) => U): U;
    mapOrElse<U>(df: () => U, mf: (a: T) => U): U;
    okOr<E>(err: E): ResultEquipped<T, E>;
    okOrElse<E>(f: () => E): ResultEquipped<T, E>;
    or(optb: Option<T>): OptionEquipped<T>;
    orElse(f: () => Option<T>): OptionEquipped<T>;
    replace(value: T): OptionEquipped<T>;
    take(): OptionEquipped<T>;
    transpose<E>(): ResultEquipped<Option<T>, E>;
    unwrap(): T;
    unwrapOr(d: T): T;
    unwrapOrElse(f: () => T): T;
    xor(optb: Option<T>): OptionEquipped<T>;
    zip<U>(optb: Option<U>): OptionEquipped<[T, U]>;
    zipWith<U, R>(optb: Option<U>, f: (a: T, b: U) => R): OptionEquipped<R>;
}
//# sourceMappingURL=equipped.d.ts.map