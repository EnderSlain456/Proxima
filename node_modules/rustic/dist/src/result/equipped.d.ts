import { Inner } from '../option/types';
import { Result, ResultKind } from './types';
import { OptionEquipped } from '../option/equipped';
/**
 * Wrapper for Result<T, E> containing all methods (that make sense)
 * from Rust's Result<T, E>
 */
export declare class ResultEquipped<T, E> {
    private _res;
    constructor(res: Result<T, E>);
    get inner(): Result<T, E>;
    get __kind(): ResultKind;
    get data(): T | E;
    isOk(): boolean;
    isErr(): boolean;
    contains(value: T): boolean;
    containsErr(value: E): boolean;
    ok(): OptionEquipped<T>;
    err(): OptionEquipped<E>;
    map<U>(f: (a: T) => U): ResultEquipped<U, E>;
    mapErr<F>(f: (a: E) => F): ResultEquipped<T, F>;
    mapOr<U>(d: U, f: (a: T) => U): U;
    mapOrElse<U>(df: () => U, mf: (a: T) => U): U;
    and<U>(res: Result<U, E>): ResultEquipped<U, E>;
    andThen<U>(f: (a: T) => Result<U, E>): ResultEquipped<U, E>;
    or<F>(res: Result<T, F>): ResultEquipped<T, F>;
    orElse<F>(f: (a: E) => Result<T, F>): ResultEquipped<T, F>;
    unwrap(): T;
    unwrapErr(): E;
    unwrapOr(d: T): T;
    unwrapOrElse(f: () => T): T;
    expect(msg: string): T;
    expectErr(msg: string): E;
    transpose<I extends Inner<T>>(): OptionEquipped<Result<I, E>>;
    flatten(): ResultEquipped<T, E>;
}
//# sourceMappingURL=equipped.d.ts.map